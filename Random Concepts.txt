1 -/ Java Code To Java Heap.  Oracle Learning  https://www.youtube.com/watch?v=FLcXf9pO27w
 
~ RAM of the computer is shared among different components.  i- OS ii- Native heap (including JVM) iii- Java Heap
~ When we create any object e.g., Integer i = new Integer(10), the amount of memory this object(refered by i) takes up in the heap is around 4x( in 32 bits) and 4*2x(in 64 bits) times the memory that int value takes(32 bits). -> 4:1
~Whenever an object is stored in the heap, apart from the actual values there are also stored some header values(overheads of object ). Like, class pointer, flags to tell whether it is an Array etc, locks for syncronization.
~Arrays has an extra overhead of size making the object to primitive size ratio 5:1. int a[] = new int[]{10};
~When a string is crated, String s = new String("MySt"), it actually creates two objects one having the reference s with overheads and the other is the object of character Array which is pointed by this reference s. This character Array stores the actual string M.y,S,t along with its overheads.erna
~Collections are the main cause to the inefficient memory usage as they are wrapper on some other objects. Example, 
~ Implementation of HashSet is a HashSet object that points to a HashMap
~A HashSet has implementation of a wrapper around HashMap, An ArryaList is the wrapper on Array of Objects. When any value is set in the HashMap it also stores the object of Entry (containing hashKey, next, key, value), therefore a HashMap without even any data in it comsumes a lot of memory.
~ Eclipse memory analyser tool tells us the usage of collections in our application i.e., how much of the collection is utilised and how much of it is epmty.

-/-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



2 -/HIBERNATE

~ORM tool to simplify the persistence of java objects in Database. Framework that Implements JPA. 
~With the help of few XML/Java Configuration files it is very easy to connect the application with databases in hibernate.
~It is lightweight, and data migration from one db to the other can be conviniently handled. Dialect property is used.
~It helps the developers not to write SQL queries manually.
~It uses HQL - Hibernate Query Language and NQL - Named Query language.

-/ CONFIGURATIONS
~Download hibernate core jars and DBMS connector jars.
~Configure the Driver class, connection url, db dialect in the hibernate.cfg.xml file

-/SAVING DATA
~@Entity annotation is mandatory on the model class/POJO to tell hibernate that the object of this class can be persisted.
~@id annotation is mandatory on one of the field of POJO to make it a primary key/ identifier of the object in DB.
~Object of Configuration is used to create the object of SessionFactory, Object of SF is used to create/get the session, object of session is used to begin and commit the Transaction for ACID.
~In the recent update configuration.buildSessionFactory();method is deprecated. This method is overloaded with one parameter which is the object of ServiceRegistry, configuration.buildSessionFactory(servReg);
~When the object of Configuration is created ->  .configure({name of cfg file}) is call the hibernate.cfg file and reads all the configuration to create the connection with the configured DB.
~session.save(entityObjectName)
											 -> .addAnnotatedClass({name of @Entity class}) maps that class with DB - ORM
~<property name="hbm2ddl.auto">update/create</property>	 is used to create the table for the entity automatically.  update - update the records in existing table; create - creates new table everytime.

-/ANNOTATIONS
~@Entity(name = "xyz_table") - change the entity name.
~@Table(name="xyz_table") , @Column((name="col_name")),  @Transient - to not store the field in the db.

-/FETCHING DATA
ABC abc = (ABC)session.get(className.class, primaryKey);

-/USE EMBEDDABLE OBJ AND FIELDS	
~When an object of some other class is used as a field in the @Entity class and we need to store the fields of that other class inside the same @Entity table, @Embeddable is used in the other class.  @Id is not used in the other class.

-/MAPPING RELATIONS.
~@OneToOne,  @OneToMany, @ManyToOne, @ManyToMany

-/FETCH EAGER , LAZY
~In the above declared relationships when we fetch the object which has a OneToMany relation (can be any with collections) with some other object (collection of thid obj in previous obj), Hibernate will only load the records for the first object and not the collection of second object which is mapped to it unless asked explicitly with getters. This is called Lazy Loading/Fetching and it is a default fetching technique. 
~In order to make it fetch the collections in one go/ eagerly we can use a property on the field of second object in the first object 
   @OneToMany(mappedBy="obj1", fetch=FetchType.EAGER).

-/ HIBERNATE CACHING.
~ First Level Cache is default in Hibernate which cache's the entity for fast retrieval. There will be separate cache for different sessions. Every session will have its own FLC.
~ Second Level Cache is shared among the sessions and has to configured using 3rd party cache like eHCache, swarm etc.
~ Steps to conf SLC :   
  ~Downloading ehCache jars for supporting it. Downloading hibernate-ehCache for integration.   Make sure the hibernate versions are same in integration jar and the workspace 
  ~Configuration in h.c.xml mentioning the use of SLC and its provider  
    <property name = "hibernate.cache.use_second_level_cache">true</property> -/ makes SLC availble for Hibernate.get,load,save methods only
    <property name = "hibernate.cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property>
	<property name = "hibernate.cache.use_query_cache">true</property>  -/to make SLC availble with the use of HQL Query as well.  In main java file -- query.setCacheable(true)

  ~ Additional annotations on @Entity class to mark the entitiy cacheable.  As not all classes are cacheable.	
	@Cacheable and @Cache(usage="CacheConcurrencyStrategy.READ_ONLY").
  
~ Whenever a query is made it will first check in FLC if not, SLC if not, DB.

-/ HQL - Hibernate Query Language.
~ With hibernate get and load methods we get the whole entity. But what if we do not want the whole entity but few columns? and Joins? That's where HQL becomes handy.
~ SQL - select column_name from tableName;   HQL - select property/fieldName from Classname. 
~ SQL - select * from student ; HQL - query = session.creatQuery("from Student"). 
~ Query q = session.createQuery("from Student"); Student is not tablename but the @Entity class name
~ when HQL query q is executed - q.list(); you get the list of objects - You can use enhanced for loop easily. While in JDBC - ResultSet is returned.

~ -/ When fetching specific properties,fields in HQL select part, the returned result is not the list of object of @Entity class but the List of array of Objects
~ We can also use SQL in hibernate with the help of -/Native Queries.  
   ~ Object of SQLQuery s = session.createSQLQuery("select * from table")  in place of Query(HQL).  s.addEntity(Student.class);  List<Student> s = s.list();
   ~ -/Similar to HQL when specific columns are retrieved the returned object is not the object of Entity class.  We can convert the result into the Map with col name as key and the actual value as value by this -> s.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP). infact it can also be done when fetching the table.
   
-/Persistence Life Cycle. Object State
~ Different state of an object in Hibernate :  Transient , Persistent (Removed), Detached. 
~ The moment we create any object it holds the transient state i.e., any change in the object will not be saved in DB 
~ If the object is stored in the DB it comes into persistent state and there is a direct linkage bw obj and db. Even if the property of the object is change after calling the save   method, it will be updated in the DB. When an object is deleted from the DB it comes into a removed state.
~ To break the linkage btween the object and the DB the object is detached and comes into a detached state.  session.detach(student)
~ Only persistent objects can be removed and detached.
~ transient, removed and detached objects are eligible for garbage collection.


-/ Difference BW get and load method. 
~ get will always fire the query and return the actuall object. load() will return the proxy object and only fire the query when that object is used, suitable when an obj is passed as an argument.
~ if the record is not present in the database, get() will return null object whereas, load() will throw NoObjectFoundException. 


-/JPA 
~Java Persistence API - A specification followed by all the ORM tools to manage the migration from one tool to other.
~ Just like hibernate, XML is used to configure the DB with the application. This xml is created in the  src/main/META-INF/resources.xml
~ Different persistent unit can be configured in the resources.xml file <persistence-unit name = "pu1">
~ Object of EntityManager is created using EntintyManagerFactory (Factory design patterns) where this pu1 is passed.
~ methods like persist() - to save,  find() - to retrieve are used.  

-/-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-/ SPRING 

-Whar is Dependency Injection 
~Feature of spring to inject the object (of one class) dependencies to some other class preventing the manual instantiation and coupling inside/of objects of the dependent class.  Example of Shape, Triangle, and Circle.  Two things which really means a lot
 1:- Main goal of Spring framework is how to decouple relationship between dependent Object
 2:- Dependency Injection means separate the class which is dependent and inject them with the needed object when its needed from outside.
 
 
-/Implementing.
~ ApplicationContext and BeanFactory are two interfaces, AC is the superset of BF, which can be used to inject the dependencies during runtime. 
~ AC is used for larger application while BF for smaller ones.

-/XML Base Configuration of application
~ Inside the calling class ->AC ac = new ClassPathXmlApplicationContext("anyName.xml");  ->  ac.getBean("beanId")  -> the beanId is configured in the anyName.xml  
      <beans> <bean id = "beanId" class ="requredObjectClass"></bean>  </beans>   -> definition of beans tag is also required.
~Just by changing the class in xml we can inject the required object to anywhere it is called using getBeans method.

-/Annotation Based Configuration of application

~ Tell the spring framework that Annotation Based Configuration is used by adding the tag   <context:component-scan base-package = "package of @Component class">
~ Use @Component annotation on the class to be injected. The default bean id will be decapitalised and dequalified name of that class.

-/ Bean Property
~ When an object has some variables, they will also act as the dependency. These variable names can also be decoupled using the <property name="fieldName" value = "val"> tag inside the bean tag. You are actually using setter.  (Setter injection)

-/Constructor Injection.
~ We can also asign the values to the fields using constructor.  <constructor-arg value="val">

-/Mixed Configuration
~ XML based and Annotation based conf. can be used together. Scenario where one obj is the field of other class. 
~ @Autowired annotation is used on the field (super interface of class) to make it count in the dependency injection.

-/Annotation Based Configuration of Spring framework
~ Make a class and mark it @Configuration, add methods with specific class return type which return the object of that class. 
~ Mark these methods with @Bean.
~ ApplicationContext ac = new AnnotationConfigApplicationContext(config.class) -> ac.getBean(Abc.class)
~ When embedded objects are used make the bean for it in the config-class also mark the embedded field @Autowired in the dependent class.

~/Getting the object without @Beans annotations
~ Mark the config file with one extra annotation @ComponentScan(basePacked= "package1","package2").
~ Mark each class with @Component as before  -> @Component functions and identify the name by type.

~ @Primary - Used on class to consider it while returning the object, @Qualifier("class1") - Used on the autowired object reference of the super interface




/-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-/ NO SQL.  NOT ONLY SQL .

~NoSQL - non-relational database in which there is no structured mechanism of storing and linking the data.  
~ It is schema less.  ~Horizontal scaling is possible. ~Since the computation is not complex the hardware costs low. And for the same reason the read and write operations are faster.
~ It uses memory very efficiently.
~ Best suited for online analytical processing. (RDB are suited in online transactional processing/storing)


-/TYPES OF NoSQL DBs.
 
 - /Columnar DB (Cassendra, HBase) 
~Data is stored column wise rather that row wise. 
~ since it is self indexing it uses less disk space corresponding to the RDB for same data(identity is assigned only once to all the similar values.)
~ Read Write and math operations are faster.


 -/Document DB( MongoDB, couchDB, RavenDB) 
~Collection of documents 
~ Data is stored in the same model in which the application code written -> hence read, write is easier and faster.  In the forms of json and xml
~ suitable to store blog/catalog and video data.

 -/Key-Value DB(Redis, DynamoDB) 
~Uses associated array to store the data. A key is associated with only one value.
~Used in session storage and caching( amazon elasticache).
~

 -/Graph-Based DB (Neo4J, flockDB) 
~ Each node represents an entitiy and each edge represents the relation between two nodes.	




--- SPRING BOOT JAVABRAINS----------------------------------------------------------------------------------------------------------------------------------------
(Pivotal>Spring)
- Bootstraping the spring application without the pain of numerous configurations. - Spring boot. 
- @SpringBootApplication - registers the annotated class as the entry point of SB application.
- SpringApplication.run(Main.class, args); - It enables the autoconfiguration. 
  - Srarts the spring application context. - scans the class path to plug in varoius components of the MVC application. - starts the servelet container and host the application into it.

- Bill of materials - A preset list of jars which are compatible with each other for the smooth operation of the application. It is approved by the spring community.

- Why embedded tomcat server -> - Convinience,  servelet container configs are now application config. With evolving application, it can be changed easily. - Makes it possible for the SB application to be a stand-alone application which can be run with a single command. - The previous point facilitates the implementation of microservises architecture eith SB.
- We can choose any other serve by adding the dependencies in pom.xml 

- @Service - marks the class as business service. This service is of singleton nature i.e., only one instance will be created by MVC and stored in the registry. 
- @Autowired - This annotation is used over the member variable of the controller class which tells spring that the controller has the dependency with the mentioned member type to inject the object of the type of this member variable in the controller. The service object which was stored in the registery will be injected.

- 4 ways to create a SB Application. 
	1. Creating a maven project and adding the dependencies manually. 
	2. Using a web tool called Spring Initilizr, which takes the project information - and provides a ready to run project zip. You can download this zip and import it into your IDE. 
	3. Using Spring command line interface (CLI) - Mainly used in quick prototyping. Using groovy scripts we can run a full fledged SB application. 
	4. Using Spring tool suite(STS) - new spring starter project -> similar parameters as in SI. 
	
- In order to configure the application as per the specific need over the opinionated nature of SB, we can use application.properties file. Different keys are used for diff. cong. 

Spring Data JPA - 

@Entity - makes the class an entity - which can be persisted in the data base using the orm framework.
@Id - makes the field the primaryKey.

- Since the basic crud operations on any entity are same, SJPA comes with the interface  CrudRepository<classType, Id type>   - this interface has to be extended by the Repository interface for every entitiy class. 
	 


--- SPRING FRAMEWORK JAVABRAINS----------------------------------------------------------------------------------------------------------------------------------------

1) Dependency injection:  In order to remove the manual process of fulfilling the dependencies between two objects, DI is implemented. It offers IOC in which an object is created by the factory (implementing factory design patterns) and whenever any other object needs that object spring injects it. 

2) Adding the jars of spring to the user libraries makes is possible to use them in multiple projects. 

3) Spring bean factory is the factoy of the spring framework which is responsible to creating and mananging the objects. There are some configuration files which acts as a bluepring for this factory on how to create the specific object. The configuration file contains the list of beans and their several other properties. Whenever any class calls the the bean with its id (refer getBean syntax), the BeanFactory scans the xml file where the configurations are done and creates the object and injects it to the target. 

4) ApplicationContext interface is built upon the BeanFactory interface, they have multiple implementations supporting differt ways of configurations(xml, @annotations)

5) In order to initialise the primitive member variables, we can use propery/constructor-arg tag inside bean tag.  Property tag gives setters injection (setter methods in pojo) and constructor-arg gives constructor injection. type and index ar used to define the data type and sequence so that the right constructor can be called. By default the value= is always of String type.

6) 7) In order to initialise the member variabe which are the objects of some other pojo- seperate bean with ref or inner beans can be used.

9) To initialise collections used as member variabe - <list> tag with <ref bean="x"> tag this bean x is also defined separately in xml is used.
    <property name = "listName">
		<list>
		 <ref bean="x"/> 
		 <ref bean="y"/> </list> 
		 </property>

10) Autowiring is a concept which lets the initialisation of the member variable(objects) without explicitly configuring in the spring xml. 
	autowire="byName" - it will compare the name of variables in pojo and id of beans in xml and initialise the objects accordingly.   injecting the valus using setters.
	autowire="byType" - compares the class of the variale with the class in xml.  - can be used with just one variable - injecting the valus using setters.
	autowire= "constructor" - similar to 2nd  - injecting the valus using constructor.
	
	When there are lot of beans in the application, it is difficult to identify the dependencies if autowiring is used. Hence on a large scale application explicit wiring is recommended.

11) Spring container creates the objects by reading the configurations in the XML file. The process of bean creation, by default, is singleton.  We can configure this frequency of bean creation. In other words we can define the scope of bean creation. 
	scope="singleton" - At the time of Intitalising ApplicationContext object it reads all the  bean config. and creates the objects and keep it in the spring container. - Done before calling getBean method. No matter how many times and from how many places the getBean method is called, there will only be single objects for each confi. bean. Not strictly a singleton because a jvm can have multiple spring containers and there can be objects of same bean in them.
	:"prototype" - a bean is created every time when getBean method is called. 
	Web-aware scopes 
	: "request" - with each http servelet request the bean is initialised.
	: "session" - For a session one bean. 
	: "global-session" - 

12) ApplicationContextAware : Lets say there is a bean class which is congigured as of singleton scope, but this bean contains other dependent beans which are configured as of prototype scope. It will not be possible to make multiple objects of sub beans since main bean is singleton. In this case, the main bean can use ApplicationContext to get the sub beans in itself(which will be executed as per the bean scope). In order to make the bean class access the ApplicationContext an interface has to be implemented by it - ApplicationContextAware, this interface contains a method setApplicationContext(ApplicationContext ac). While runtime, spring will search for the classes impl. this interface and automatically pass the ApplicationContext object in the setApplicationContext method. This object can be captured in a member variable and used for further bean calls.  
 BeanNameAware : gives the name of bean in the XML
 
13) Bean Definition inheritance.  - Inheriting the properties configuration of one bean to the other.  using parameter parent="parentbeanid";  
	- Along with single properties, list or any collection of properties can be inherited, and additional elements can be added in the list using  <list merge="true"> in child bean. 
	- if we want to restrict parent bean from getting initialised using getBean method  abstract="true" parameter is used in bean tag.
	
14) Lifecycle Callback - In order to bind methods with beans, that are called during start of the application(bean creation) and at the end of the application. We can implement two interfaces in the bean class - InitialisingBean (method - afterPropertiesSet())  2- DisposableBean (method - destroy()). 
	-In the main class, instead of Application context we can use AbstractApplicationContext class, and register a shut down hook with the context (context.registerShutdownHook()). So that when the application ends this hook is called and destroys all the beans which inturns call the destroy method in the implemented bean class. 
	-Spring automatically registers the methods while component scan. 
	
	If we do not want to implement these spring specific interfaces and make class level changes, bean configuration can be done at xml level. 4
		- First write the methods in the bean pojo class then in the bean tag - write init-method="" destroy-method=""
		- If you want to make these calls global for all beans then in the beanS tag write default-init-method ="" default-destroy-method="" -- if the bean class implements these methods, they'll be called else ignored. 
		
	If with use both these methods of callback configuration- both the confi methods will be executed but first the interface implemented ones and then the xml configured ones
	- Shutdown hook needs to be registered in both the approaches.
	
15) - BeanPostProcessor - If we want to execute a piece of code before and after the initialisation of all the beans defined in the xml we create a separate class and implement this BPP interface. 
	- It is basically done in order to extend the functionality of the spring framework. 
	- The interface contains two methods  - postProcessBeforeInitialisation and ...afterIni..(Object bean, String beanName)  -> 
	- We need to create the bean config. for this new class to let spring know it's existance and spring will automatically figure out scanning the implementation of the interface.
	- Note that there is not destroy method here, only methods fot initialisation.
16) - BeanFactoryPostProcessor  - Same as BPP but the execution takes place during the startirng of BF i.e., even before the BF creates singleton/(as configured) objects of the beans /  or before preInstantiateSingletons. 
	- Only one method  - postProcessBeanFactory(ConfigurableListableBeanFactory bf)
	- PropertyPlaceholderConfigurer is an inbuilt BFPP, which is used to replace the placeholders in the xml with the actual value defined in the properties file. Define bean for this class as well in xml and inside property tag define the name="locations" and value = "xyz.properties". 
17) - Coding to interfaces - instead of storing the bean (context.getBean("beanId"))to a particular class we can store it in a parent interfaces of all the similar classes  Shape(I), Triangle(C), Circle(C). This enables the dynamic binding of beans. 

18) @Required annotation - allows us to specifies which dependencies are required. We need to configure a beanpostprocessor - RequireAnnotationBPP - which will scan this annotation and let jvm know the mandatory properties. If the properties are not set then it will throw an ex. much before the actual code gets implemented. This annotation can be used on a setter of the dependent field.
	
19) @Autowired - This annotation is used to autowire the dependencies. When used over a setter/field it first scans the xml for the type of the field, if there is only one bean of that type in xml it will inject the dependencies but if there are more beans of the same type, the next step it does is to look at the matching id/name of the bean. 
-  We need to configure a beanpostprocessor - AutowiredAnnotationBPP 
-  If there are multiple beans of same type, and also no match in the name - we can use @Qualifier("xyzRelated") along with @Autowired on the field/setter, and a new tag <qualifier value = "xyzRelated"/> in the bean which we want to get injected.  *Add namespaces in bean tag to use tags like qualifier etc.

- To save defining the BPP everytime, there is a tag <context:annotation-config/> which defines all the inbuilt BPP\

20) - JSR-250 Annotation -   Java Specification Request- 250 - defines all the standard annotation that would apply across different technologies and framework. NOT Spring specific annotation
  @Resource(name="beanNameInXML") - on the setter of dependent field.
  @PostConstruct - on custom init method.
  @PreDestroy - on custom destroy method.    all three are from javax.annotations
  
21) Stereotype annotations (in the stereotype package) - Till now, in order to register a bean we have to config the bean in XML. 
						   - There are certain annotations which lets us define the bean during the class declaration itself. 
						   - One such bean is @Component - this is used over a class and marks it as a bean. Addon work is just to define a tag  <context:component-scan base-package = "packageName"/> 
						   - This tag in the xml lets spring knows that there are beans defined using annotations - and during component-scan the spring registers these annotated classes as beans. 
						   - When we make any enterprise application using MVC design, there are certain classes with different roles. Spring lets us define these roles using annotation. 
								- In place of generic @Component, we can use below annotation defining the class as a bean with specific role. 
									@Controller - C 
									@Service - buissiness logic /service layer
									@Repository - Data layer
	Disadvantage of using annotated bean declaration is that there will be a single instance. Whereas in xml we can define multiple bean of same class with different metadata(e.g. - Points). 
	
	
22) MessageSource to get data from properties file - ApplicationContext is BeanFactory + additional functionality.  These additional functionality includes Messagin and Internationalisation. 
	- In order to decouple the message from the code we can use a properties file in which the data is kept in k-v pair. 
	- A bean of class ResourceBundleMessageSource is to be created and this bean contains the property tag containing the list of all the properties files in the class path. 
	- Using the object of ApplicationContext  a method is called - context.getMessage("keyName", placeholders, "default msg", locale)
	
	- In order to use this outside the main method we can use ACAware to get the context object in any bean but there's already the same method - getMessage in the ResourceBundleMessageSource class. 
	- So with the help of a local variable of type MessageSource with @Autowired annotation we can call this method. 
	- When there are parameters/placeholders in the value against any key e.g., Point cordinates are:({0},{1}) - We need to pass an array of object in the getMessage to substitute them.
	
	- Internationalisation - using locale. adding suffix _en, _tam etc in the properties file. And passing the same as the last argument of the getMessage method.
	
23) - Second additional feature of AC over BF - Event Handling -  
		- Any event has three components -  event, eventpublisher, and eventListner. 
		- With the help of application context we can create these components. 
		- EventClass implements ApplicationEvent   - contains parameterised constructor taking the event source class object and calling the super constructor. Overriden toString
		- EListnerClass implements ApplicationListener -  onApplicationEvent(ApplicationEvent event) { print}
		- EPublishClass - is the class in which we need to initiate this event. This class will implement ApplicationEventPublisherAware -  
		     impl method -    setApplicationEventPublisher(ApplicationEventPublisher publ){this.publ = publ}->  publ.publishEvent(new EventClass(this)) - Behind the scene this method is implemented in ApplicationContext so Application context is the provider of event handling. 
									
24)- AOP - Aspect oriented programming. - It is a programming paradigm and not specific to spring. It is another way if implementing IOC. There are certain cross cutting concerns/functionalities which every application need to implement. For example you have 3 classes and mrthods of these classes logs the flow of execution. In traditional way either we can make a logging method in all the classes, or make a logging class and call its method in all other classes. This way is cumbursome. To make this cross cutting concern of logging more efficient Aspects are used instead of classes. 
	-You can create an Aspect of Logging, Transaction, Security and other concerns, and configure the methods for which these Aspect need to be called in a separate file Aspect-Configuration. 
	-This saves a whole lot of time and re-writing. In future if any other method of any class needs the Security aspect, adding config. in the AC will do the work.
									
									
									
25) Setting up the dev env. for AOP -  Jars to be added  in the classpath (add in a user library)- 1) aspectj, aspectjweaver 2) aopalliance 3) cgilib 4) asm.
26) Writing our first aspect. -   *Spring framework distribution - project folder  - in order to get the standard files, specific namespaces for xml, etc.*
	Similar Shape serivice is used, Aspect of loggin will be implemented to log the execution flow , when getName of service is called.  
	*context.getBean("beanId", Bean.class) - no need to cast the object manually, spring takes care of it.*
	
	Part 2 - Aspect is just a class with a specific annotation - @Aspect (org.aspectj.annotation). In this we can write as many methods we want. These methods are called advice - standard terminology of AOP.
	- There are certain annotation which are to be added on these advices methods to tell/configure their execution. E.g.,
		@Before("execution(public String getName)") - This will tell spring to execute the advice method before the execution of getName() -whenever and wherever in the project it is encountered.
	- In order to make Spring aware of the AOP implementation a special tag is to be added in the xml file -<aop:aspectj-autoproxy/>
	- Bean of the aspect class is to be configured in the xml

28) Pointcut and Wildcard expression. 
	@Before("execution(public String PACKAGENAME.CLASSNAME.getName)")  - In order to restrict the execution of the advice for a particular class.
	
	WILDCARDS - Let's suppose you need to configure single advice with multiple methods - to be specific multiple getters. 
	@Before("execution(public * get*)")     -before the execution of all the public methods irrespective of the return type and name starting with get having 0 argument, this advice will be called. So Shape.getCircle.getName() - will trigger this advice twice.
	@Before("execution(public * get*(*))")  applied to all getters with one or more arguments
	@Before("execution(public * get*(..))") - applied to all getter whether they have arguments or not. .. - it can be 0 or it can be any number of argument. Most suitable.
	@Before("execution(public * PACKAGENAME.*.get*(..))") -applied on getters in all the classes in the package.
	
	POINTCUTS -  Let's suppose you need to configure multiple advices with single method- One way of doing it is adding same annotation on multiple advice methods(which can be cumbursom in the long run).
		- The expression passed in @Before annotation is called a Pointcut expression - i.e., a cut in the point of code where the advice method execution will be filled. 
		- In order to  configure multiple advices with single method more efficiently, we can define a pointcut for that point using @Pointcut("execution(public * get*(..))") over a method without any executable lines. And this method name can be replaced in the @Before("PointcutAnnotatedMethod()") - This saves a lot of typing
		
29) A few more Pointcut expressions: '

	WITHIN:
	@Pointcut("execution(* * PACKAGENAME.className.*(..))") can be writter using within keyword @Pointcut("within(packagename.className)")  - applies to all methods in the class
	@Pointcut("within(packagename.*)") - applies to all methods in the class in the package
	@Pointcut("within(packagename..*)") - applies to all methods in the class in the package and subpackage(..)
	 --within keyword takes classname while execution keyword takes method name as end point.
	 
	ARGS:  Defines the agruments that a method in the code takes. Takes in classes and interfaces as parameter. Can take multiple arguments. Whichever method matches the arguments, grtd applied with the advice.
	
	GOOD PRACTICE:  Combining the pointcuts. Insoide @Before. Using && operator. Just like writing the condition in if statememt.
	
30) JoinPoint and Advice argument: 
	JOINPOINT
	 - If an advice is getting executed for all the methods of a class, we would want to print customised logs based on the method which triggered the advice. This can be done by passing the reference of Joinpoint as an argument in the advice method. Spring automatically passes its object to the advice method. 
	 - toString implementation of joinpoint prints the complete pointcut which lets us know the target method.
	 - There are methods in this object, which allows us to get hold of the target. for ex, joinpoint.getTarget gives the object of the class.
						
	ADVICE ARGUMENT
		- Lets say we have an advice which is getting called for all the the methods having String type as an argument.  We would write @Before("args(String)");
		- To get hold of the value of this argument we can also write it as @Before("args(name)") piblic void setAdvice(String name){...};  Since we are defining the type of name in advice argument, Spring will resolve it while runtime, for what methods we need to call the advice.
		
31) After advice: 
	
	- @After("poincutExp") - To call the advice the method after the point cut method has been executed. This advice will be called irrespective of the successful execution of pointcut method. 
		                   - This advice will not be called after the spring container initialise the beans.
	- @AfterReturning("poincutExp")- In order to control this behavioir, i.e., calling the advice method only after successful execution(without any exception) - 
	-  @AfterThrowing("poincutExp")- if the exception is thrown.
			
	-@AfterReturning(pointcut="args(name)", returning="returnString") public void returnAdv(String name, String/Object returnString)  - get hold of the return value.
	-@AfterReturning(pointcut="args(name)", throwing="ex") public void throwAdv(String name, RuntimeException ex)- to get hold of the exception.							
	
									
32) @Around advice - In order to combine the feature of Before and After advice. Around advice can be used. 
				- The advice method must have ProceedJoinPoint reference as an argument. With this object(passed by spring) we can controll the execution of the target methods(getters in this case)
				- returnValue = ProceedJoinPoint.proceed() methods indicates that the target method will be executed. Anything before and after this line will be logged before and after the execution.
				- must be enclosed in a try catch - Anything written in catch block will be logged if the target method throws an exception.
				- Benefits of using Around - a method variable is shared before and after in a thread safe manner. 
				- The best practice is to use the lest powerful annotation which is enough for serving the use case.
				- The advice method must return the return type of target method in case of Around annotation.
				
33) Naming convention and custom annotation. 
		NC - Proper naming convention while naming the classes and packages must be followed. It makes the project organised and also makes it easier to use wild card patterns in the pointcut expressions.
		CustomAnnotation - A custom annotation can be created and the target method can be annotated with it (eg- @Loggable) And instead of using the pointcut expression we can use @Before("@annotation(packageName.Loggable)")  this advice will be called before all the methods which are annotated with @Loggable.
		
34) AOP XML Configuration:  Preferred when an aspect is to be treated as a configuration(debugging aspect) rather than a part of the functionality(transaction aspect)
	In place of annotations on the class, xml tags are used.  In the spring xml where beans are defined. We can config aop within 
		<aop:config> 
		  <aop:aspect id="xyz" ref="beanNameOfAspClass">  
				<aop:around pointcut="pexpression" method = "adviceMethodName">
		  </aop:aspect>
		</aop:config>
									
	

	

---------------------------------------------------------------------------SRPING SECURITY	


1) What is spring security. 
             - it is an application framework that helps in application level security. You can ask for a specific thing and spring can make it available e.g.,
		- Login and logout functionalities, URI access controll only for loggedin user,  URI access controll only for loggedin user with specific roles.
		-ou can configure spring security in your application as per the specific requirement.\
		-Since the implementation of security can vary, spring security is very flexible and customisable.
		-Why spring security? 
			- It handles common vulnurabilities line - session fixation, clickjacking, csrf.
			- Widely adoptes - evolving frequently.
		- With spring security you can implement: 
			- username passwod authentication.
			- Single sign on - Okta/LDAPCertStoreParameters
			- Application level authorisation in addition to authentication.
			- Intra application authentication using OAuth
			- Microservices authentication (JWT) - When one MS communicating with other. Assuring the inaccessible data is not shared.
			- Method level security - In addition to URI and API authentication. More granular.
			
2) 5 Core concepts in SS: 
	- AUTHENTICATION:
	- AUTHORISATION:
	- PRINCIPAL:
	- GRANTED AUTHORITY:
	- ROLES:
			
		
						  


















