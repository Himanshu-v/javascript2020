1 -/ Java Code To Java Heap.  Oracle Learning  https://www.youtube.com/watch?v=FLcXf9pO27w
 
~ RAM of the computer is shared among different components.  i- OS ii- Native heap (including JVM) iii- Java Heap
~ When we create any object e.g., Integer i = new Integer(10), the amount of memory this object(refered by i) takes up in the heap is around 4x( in 32 bits) and 4*2x(in 64 bits) times the memory that int value takes(32 bits). -> 4:1
~Whenever an object is stored in the heap, apart from the actual values there are also stored some header values(overheads of object ). Like, class pointer, flags to tell whether it is an Array etc, locks for syncronization.
~Arrays has an extra overhead of size making the object to primitive size ratio 5:1. int a[] = new int[]{10};
~When a string is crated, String s = new String("MySt"), it actually creates two objects one having the reference s with overheads and the other is the object of character Array which is pointed by this reference s. This character Array stores the actual string M.y,S,t along with its overheads.erna
~Collections are the main cause to the inefficient memory usage as they are wrapper on some other objects. Example, 
~ Implementation of HashSet is a HashSet object that points to a HashMap
~A HashSet has implementation of a wrapper around HashMap, An ArryaList is the wrapper on Array of Objects. When any value is set in the HashMap it also stores the object of Entry (containing hashKey, next, key, value), therefore a HashMap without even any data in it comsumes a lot of memory.
~ Eclipse memory analyser tool tells us the usage of collections in our application i.e., how much of the collection is utilised and how much of it is epmty.

-/-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



2 -/HIBERNATE

~ORM tool to simplify the persistence of java objects in Database. Framework that Implements JPA. 
~With the help of few XML/Java Configuration files it is very easy to connect the application with databases in hibernate.
~It is lightweight, and data migration from one db to the other can be conviniently handled. Dialect property is used.
~It helps the developers not to write SQL queries manually.
~It uses HQL - Hibernate Query Language and NQL - Named Query language.

-/ CONFIGURATIONS
~Download hibernate core jars and DBMS connector jars.
~Configure the Driver class, connection url, db dialect in the hibernate.cfg.xml file

-/SAVING DATA
~@Entity annotation is mandatory on the model class/POJO to tell hibernate that the object of this class can be persisted.
~@id annotation is mandatory on one of the field of POJO to make it a primary key/ identifier of the object in DB.
~Object of Configuration is used to create the object of SessionFactory, Object of SF is used to create/get the session, object of session is used to begin and commit the Transaction for ACID.
~In the recent update configuration.buildSessionFactory();method is deprecated. This method is overloaded with one parameter which is the object of ServiceRegistry, configuration.buildSessionFactory(servReg);
~When the object of Configuration is created ->  .configure({name of cfg file}) is call the hibernate.cfg file and reads all the configuration to create the connection with the configured DB.
~session.save(entityObjectName)
											 -> .addAnnotatedClass({name of @Entity class}) maps that class with DB - ORM
~<property name="hbm2ddl.auto">update/create</property>	 is used to create the table for the entity automatically.  update - update the records in existing table; create - creates new table everytime.

-/ANNOTATIONS
~@Entity(name = "xyz_table") - change the entity name.
~@Table(name="xyz_table") , @Column((name="col_name")),  @Transient - to not store the field in the db.

-/FETCHING DATA
ABC abc = (ABC)session.get(className.class, primaryKey);

-/USE EMBEDDABLE OBJ AND FIELDS	
~When an object of some other class is used as a field in the @Entity class and we need to store the fields of that other class inside the same @Entity table, @Embeddable is used in the other class.  @Id is not used in the other class.

-/MAPPING RELATIONS.
~@OneToOne,  @OneToMany, @ManyToOne, @ManyToMany

-/FETCH EAGER , LAZY
~In the above declared relationships when we fetch the object which has a OneToMany relation (can be any with collections) with some other object (collection of thid obj in previous obj), Hibernate will only load the records for the first object and not the collection of second object which is mapped to it unless asked explicitly with getters. This is called Lazy Loading/Fetching and it is a default fetching technique. 
~In order to make it fetch the collections in one go/ eagerly we can use a property on the field of second object in the first object 
   @OneToMany(mappedBy="obj1", fetch=FetchType.EAGER).

-/ HIBERNATE CACHING.
~ First Level Cache is default in Hibernate which cache's the entity for fast retrieval. There will be separate cache for different sessions. Every session will have its own FLC.
~ Second Level Cache is shared among the sessions and has to configured using 3rd party cache like eHCache, swarm etc.
~ Steps to conf SLC :   
  ~Downloading ehCache jars for supporting it. Downloading hibernate-ehCache for integration.   Make sure the hibernate versions are same in integration jar and the workspace 
  ~Configuration in h.c.xml mentioning the use of SLC and its provider  
    <property name = "hibernate.cache.use_second_level_cache">true</property> -/ makes SLC availble for Hibernate.get,load,save methods only
    <property name = "hibernate.cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property>
	<property name = "hibernate.cache.use_query_cache">true</property>  -/to make SLC availble with the use of HQL Query as well.  In main java file -- query.setCacheable(true)

  ~ Additional annotations on @Entity class to mark the entitiy cacheable.  As not all classes are cacheable.	
	@Cacheable and @Cache(usage="CacheConcurrencyStrategy.READ_ONLY").
  
~ Whenever a query is made it will first check in FLC if not, SLC if not, DB.

-/ HQL - Hibernate Query Language.
~ With hibernate get and load methods we get the whole entity. But what if we do not want the whole entity but few columns? and Joins? That's where HQL becomes handy.
~ SQL - select column_name from tableName;   HQL - select property/fieldName from Classname. 
~ SQL - select * from student ; HQL - query = session.creatQuery("from Student"). 
~ Query q = session.createQuery("from Student"); Student is not tablename but the @Entity class name
~ when HQL query q is executed - q.list(); you get the list of objects - You can use enhanced for loop easily. While in JDBC - ResultSet is returned.

~ -/ When fetching specific properties,fields in HQL select part, the returned result is not the list of object of @Entity class but the List of array of Objects
~ We can also use SQL in hibernate with the help of -/Native Queries.  
   ~ Object of SQLQuery s = session.createSQLQuery("select * from table")  in place of Query(HQL).  s.addEntity(Student.class);  List<Student> s = s.list();
   ~ -/Similar to HQL when specific columns are retrieved the returned object is not the object of Entity class.  We can convert the result into the Map with col name as key and the actual value as value by this -> s.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP). infact it can also be done when fetching the table.
   
-/Persistence Life Cycle. Object State
~ Different state of an object in Hibernate :  Transient , Persistent (Removed), Detached. 
~ The moment we create any object it holds the transient state i.e., any change in the object will not be saved in DB 
~ If the object is stored in the DB it comes into persistent state and there is a direct linkage bw obj and db. Even if the property of the object is change after calling the save   method, it will be updated in the DB. When an object is deleted from the DB it comes into a removed state.
~ To break the linkage btween the object and the DB the object is detached and comes into a detached state.  session.detach(student)
~ Only persistent objects can be removed and detached.
~ transient, removed and detached objects are eligible for garbage collection.


-/ Difference BW get and load method. 
~ get will always fire the query and return the actuall object. load() will return the proxy object and only fire the query when that object is used, suitable when an obj is passed as an argument.
~ if the record is not present in the database, get() will return null object whereas, load() will throw NoObjectFoundException. 


-/JPA 
~Java Persistence API - A specification followed by all the ORM tools to manage the migration from one tool to other.
~ Just like hibernate, XML is used to configure the DB with the application. This xml is created in the  src/main/META-INF/resources.xml
~ Different persistent unit can be configured in the resources.xml file <persistence-unit name = "pu1">
~ Object of EntityManager is created using EntintyManagerFactory (Factory design patterns) where this pu1 is passed.
~ methods like persist() - to save,  find() - to retrieve are used.  

-/-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-/ SPRING 

-Whar is Dependency Injection 
~Feature of spring to inject the object (of one class) dependencies to some other class preventing the manual instantiation and coupling inside/of objects of the dependent class.  Example of Shape, Triangle, and Circle.  Two things which really means a lot
 1:- Main goal of Spring framework is how to decouple relationship between dependent Object
 2:- Dependency Injection means separate the class which is dependent and inject them with the needed object when its needed from outside.
 
 
-/Implementing.
~ ApplicationContext and BeanFactory are two interfaces, AC is the superset of BF, which can be used to inject the dependencies during runtime. 
~ AC is used for larger application while BF for smaller ones.

-/XML Base Configuration of application
~ Inside the calling class ->AC ac = new ClassPathXmlApplicationContext("anyName.xml");  ->  ac.getBean("beanId")  -> the beanId is configured in the anyName.xml  
      <beans> <bean id = "beanId" class ="requredObjectClass"></bean>  </beans>   -> definition of beans tag is also required.
~Just by changing the class in xml we can inject the required object to anywhere it is called using getBeans method.

-/Annotation Based Configuration of application

~ Tell the spring framework that Annotation Based Configuration is used by adding the tag   <context:component-scan base-package = "package of @Component class">
~ Use @Component annotation on the class to be injected. The default bean id will be decapitalised and dequalified name of that class.

-/ Bean Property
~ When an object has some variables, they will also act as the dependency. These variable names can also be decoupled using the <property name="fieldName" value = "val"> tag inside the bean tag. You are actually using setter.  (Setter injection)

-/Constructor Injection.
~ We can also asign the values to the fields using constructor.  <constructor-arg value="val">

-/Mixed Configuration
~ XML based and Annotation based conf. can be used together. Scenario where one obj is the field of other class. 
~ @Autowired annotation is used on the field (super interface of class) to make it count in the dependency injection.

-/Annotation Based Configuration of Spring framework
~ Make a class and mark it @Configuration, add methods with specific class return type which return the object of that class. 
~ Mark these methods with @Bean.
~ ApplicationContext ac = new AnnotationConfigApplicationContext(config.class) -> ac.getBean(Abc.class)
~ When embedded objects are used make the bean for it in the config-class also mark the embedded field @Autowired in the dependent class.

~/Getting the object without @Beans annotations
~ Mark the config file with one extra annotation @ComponentScan(basePacked= "package1","package2").
~ Mark each class with @Component as before  -> @Component functions and identify the name by type.

~ @Primary - Used on class to consider it while returning the object, @Qualifier("class1") - Used on the autowired object reference of the super interface




/-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-/ NO SQL.  NOT ONLY SQL .

~NoSQL - non-relational database in which there is no structured mechanism of storing and linking the data.  
~ It is schema less.  ~Horizontal scaling is possible. ~Since the computation is not complex the hardware costs low. And for the same reason the read and write operations are faster.
~ It uses memory very efficiently.
~ Best suited for online analytical processing. (RDB are suited in online transactional processing/storing)


-/TYPES OF NoSQL DBs.
 
 - /Columnar DB (Cassendra, HBase) 
~Data is stored column wise rather that row wise. 
~ since it is self indexing it uses less disk space corresponding to the RDB for same data(identity is assigned only once to all the similar values.)
~ Read Write and math operations are faster.


 -/Document DB( MongoDB, couchDB, RavenDB) 
~Collection of documents 
~ Data is stored in the same model in which the application code written -> hence read, write is easier and faster.  In the forms of json and xml
~ suitable to store blog/catalog and video data.

 -/Key-Value DB(Redis, DynamoDB) 
~Uses associated array to store the data. A key is associated with only one value.
~Used in session storage and caching( amazon elasticache).
~

 -/Graph-Based DB (Neo4J, flockDB) 
~ Each node represents an entitiy and each edge represents the relation between two nodes.	




--- SPRING BOOT JAVABRAINS----------------------------------------------------------------------------------------------------------------------------------------
(Pivotal>Spring)
- Bootstraping the spring application without the pain of numerous configurations. - Spring boot. 
- @SpringBootApplication - registers the annotated class as the entry point of SB application.
- SpringApplication.run(Main.class, args); - It enables the autoconfiguration. 
  - Srarts the spring application context. - scans the class path to plug in varoius components of the MVC application. - starts the servelet container and host the application into it.

- Bill of materials - A preset list of jars which are compatible with each other for the smooth operation of the application. It is approved by the spring community.

- Why embedded tomcat server -> - Convinience,  servelet container configs are now application config. With evolving application, it can be changed easily. - Makes it possible for the SB application to be a stand-alone application which can be run with a single command. - The previous point facilitates the implementation of microservises architecture eith SB.
- We can choose any other serve by adding the dependencies in pom.xml 

- @Service - marks the class as business service. This service is of singleton nature i.e., only one instance will be created by MVC and stored in the registry. 
- @Autowired - This annotation is used over the member variable of the controller class which tells spring that the controller has the dependency with the mentioned member type to inject the object of the type of this member variable in the controller. The service object which was stored in the registery will be injected.

- 4 ways to create a SB Application. 
	1. Creating a maven project and adding the dependencies manually. 
	2. Using a web tool called Spring Initilizr, which takes the project information - and provides a ready to run project zip. You can download this zip and import it into your IDE. 
	3. Using Spring command line interface (CLI) - Mainly used in quick prototyping. Using groovy scripts we can run a full fledged SB application. 
	4. Using Spring tool suite(STS) - new spring starter project -> similar parameters as in SI. 
	
- In order to configure the application as per the specific need over the opinionated nature of SB, we can use application.properties file. Different keys are used for diff. cong. 

Spring Data JPA - 

@Entity - makes the class an entity - which can be persisted in the data base using the orm framework.
@Id - makes the field the primaryKey.

- Since the basic crud operations on any entity are same, SJPA comes with the interface  CrudRepository<classType, Id type>   - this interface has to be extended by the Repository interface for every entitiy class. 
	 


--- SPRING FRAMEWORK JAVABRAINS----------------------------------------------------------------------------------------------------------------------------------------

1) Dependency injection:  In order to remove the manual process of fulfilling the dependencies between two objects, DI is implemented. It offers IOC in which an object is created by the factory (implementing factory design patterns) and whenever any other object needs that object spring injects it. 

2) Adding the jars of spring to the user libraries makes is possible to use them in multiple projects. 

3) Spring bean factory is the factoy of the spring framework which is responsible to creating and mananging the objects. There are some configuration files which acts as a bluepring for this factory on how to create the specific object. The configuration file contains the list of beans and their several other properties. Whenever any class calls the the bean with its id (refer getBean syntax), the BeanFactory scans the xml file where the configurations are done and creates the object and injects it to the target. 

4) ApplicationContext interface is built upon the BeanFactory interface, they have multiple implementations supporting differt ways of configurations(xml, @annotations)

5) In order to initialise the primitive member variables, we can use propery/constructor-arg tag inside bean tag.  Property tag gives setters injection (setter methods in pojo) and constructor-arg gives constructor injection. type and index ar used to define the data type and sequence so that the right constructor can be called. By default the value= is always of String type.

6) 7) In order to initialise the member variabe which are the objects of some other pojo- seperate bean with ref or inner beans can be used.

9) To initialise collections used as member variabe - <list> tag with <ref bean="x"> tag this bean x is also defined separately in xml is used.
    <property name = "listName">
		<list>
		 <ref bean="x"/> 
		 <ref bean="y"/> </list> 
		 </property>

10) Autowiring is a concept which lets the initialisation of the member variable(objects) without explicitly configuring in the spring xml. 
	autowire="byName" - it will compare the name of variables in pojo and id of beans in xml and initialise the objects accordingly.   injecting the valus using setters.
	autowire="byType" - compares the class of the variale with the class in xml.  - can be used with just one variable - injecting the valus using setters.
	autowire= "constructor" - similar to 2nd  - injecting the valus using constructor.
	
	When there are lot of beans in the application, it is difficult to identify the dependencies if autowiring is used. Hence on a large scale application explicit wiring is recommended.

11) Spring container creates the objects by reading the configurations in the XML file. The process of bean creation, by default, is singleton.  We can configure this frequency of bean creation. In other words we can define the scope of bean creation. 
	scope="singleton" - At the time of Intitalising ApplicationContext object it reads all the  bean config. and creates the objects and keep it in the spring container. - Done before calling getBean method. No matter how many times and from how many places the getBean method is called, there will only be single objects for each confi. bean. Not strictly a singleton because a jvm can have multiple spring containers and there can be objects of same bean in them.
	:"prototype" - a bean is created every time when getBean method is called. 
	Web-aware scopes 
	: "request" - with each http servelet request the bean is initialised.
	: "session" - For a session one bean. 
	: "global-session" - 

12) ApplicationContextAware : Lets say there is a bean class which is congigured as of singleton scope, but this bean contains other dependent beans which are configured as of prototype scope. It will not be possible to make multiple objects of sub beans since main bean is singleton. In this case, the main bean can use ApplicationContext to get the sub beans in itself(which will be executed as per the bean scope). In order to make the bean class access the ApplicationContext an interface has to be implemented by it - ApplicationContextAware, this interface contains a method setApplicationContext(ApplicationContext ac). While runtime, spring will search for the classes impl. this interface and automatically pass the ApplicationContext object in the setApplicationContext method. This object can be captured in a member variable and used for further bean calls.  
 BeanNameAware : gives the name of bean in the XML
 
13) Bean Definition inheritance.  - Inheriting the properties configuration of one bean to the other.  using parameter parent="parentbeanid";  
	- Along with single properties, list or any collection of properties can be inherited, and additional elements can be added in the list using  <list merge="true"> in child bean. 
	- if we want to restrict parent bean from getting initialised using getBean method  abstract="true" parameter is used in bean tag.
	
14) Lifecycle Callback - In order to bind methods with beans, that are called during start of the application(bean creation) and at the end of the application. We can implement two interfaces in the bean class - InitialisingBean (method - afterPropertiesSet())  2- DisposableBean (method - destroy()). 
	-In the main class, instead of Application context we can use AbstractApplicationContext class, and bind a shud down hook with the context. So that when the application ends this hook is called which inturns call the destroy method in the implemented bean class. 
	-Spring automatically registers the methods while component scan. 
	
